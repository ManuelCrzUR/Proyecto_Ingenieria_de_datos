#Escenario 1

from dash import Dash, html, dcc
import plotly.express as px
import pandas as pd
import psycopg2

try:
    connection = psycopg2.connect(
        host='localhost',
        user='postgres',
        password='123456789',
        database='pr_final',
        port="5432"
    )
    print("Conexión exitosa")
    cursor = connection.cursor()
    cursor.execute("SELECT id_nomenclatura, estado_amenaza, id_amenaza FROM especies_amenazadas")
    rows = cursor.fetchall()
    
    lista_icn = []
    lista_iczn = []
    
    for row in rows:
        if row[0] == 'ICN':
            lista_icn.append(row)
        elif row[0] == 'ICZN':
            lista_iczn.append(row)
        else:
            print("No se puede añadir el dato: ", row)

    # Convertir los resultados a DataFrames de Pandas
    df_icn = pd.DataFrame(lista_icn, columns=['Nomenclatura', 'Estado de Amenaza', 'ID Amenaza'])
    df_iczn = pd.DataFrame(lista_iczn, columns=['Nomenclatura', 'Estado de Amenaza', 'ID Amenaza'])

    # Contar el número de especies en cada estado de amenaza
    df_icn_count = df_icn['Estado de Amenaza'].value_counts().reset_index()
    df_icn_count.columns = ['Estado de Amenaza', 'Número de Especies']

    df_iczn_count = df_iczn['Estado de Amenaza'].value_counts().reset_index()
    df_iczn_count.columns = ['Estado de Amenaza', 'Número de Especies']

    app = Dash(__name__)

    # Definir un diccionario de colores específico para cada estado de amenaza
    color_mapping = {
        'EN': '#FF0000',  # Rojo
        'CR': '#FFA500',  # Naranja
        'VU': '#FFFF00',  # Amarillo
    }

    # Obtener el orden de categorías del primer DataFrame
    category_order = df_icn_count['Estado de Amenaza'].tolist()

    # Crear las gráficas con colores específicos y el mismo orden de categorías
    fig_icn = px.bar(df_icn_count, 
                     x='Estado de Amenaza', 
                     y='Número de Especies', 
                     title='ICN - Número de Especies por Estado de Amenaza',
                     color='Estado de Amenaza',
                     color_discrete_map=color_mapping,
                     category_orders={'Estado de Amenaza': category_order})

    fig_iczn = px.bar(df_iczn_count, 
                      x='Estado de Amenaza', 
                      y='Número de Especies', 
                      title='ICZN - Número de Especies por Estado de Amenaza',
                      color='Estado de Amenaza',
                      color_discrete_map=color_mapping,
                      category_orders={'Estado de Amenaza': category_order})

    # Configurar el fondo transparente para las gráficas
    fig_icn.update_layout({
        'plot_bgcolor': 'rgba(0, 0, 0, 0)',
        'paper_bgcolor': 'rgba(0, 0, 0, 0)',
    })

    fig_iczn.update_layout({
        'plot_bgcolor': 'rgba(0, 0, 0, 0)',
        'paper_bgcolor': 'rgba(0, 0, 0, 0)',
    })

    app.layout = html.Div([
        html.H1("Análisis de Especies Amenazadas"),
        dcc.Graph(figure=fig_icn),
        dcc.Graph(figure=fig_iczn),
        html.P("Con esto concluiríamos el análisis del proyecto esperando que sea de su agrado.")
    ], style={'backgroundColor': '#FFFFFF'})  # Color de fondo de la página

    if __name__ == '__main__':
        app.run_server(debug=True)
except Exception as ex:
    print("Error durante la conexión o ejecución:", ex)
finally:
    if cursor:
        cursor.close()
    if connection:
        connection.close()
    print("Conexión finalizada")

#Escenario 2

from dash import Dash, html, dcc
import plotly.express as px
import pandas as pd
import psycopg2

try:
    connection = psycopg2.connect(
        host='localhost',
        user='postgres',
        password='123456789',
        database='pr_final',
        port="5432"
    )
    print("Conexión exitosa")
    cursor = connection.cursor()
    cursor.execute("SELECT reino, filio FROM clasificacion_superior")
    rows = cursor.fetchall()
    
    lista_a = []
    lista_p = []
    lista_f = []
    
    for row in rows:
        if row[0] == 'Fungi':
            lista_f.append(row[1])
        elif row[0] == 'Plantae':
            lista_p.append(row[1])
        elif row[0] == 'Animalia':
            lista_a.append(row[1])
        else:
            print("dato no es posible de añadir")

    # Contar la frecuencia de cada filo en cada reino
    df_fungi = pd.DataFrame(lista_f, columns=['Filo'])
    df_plantae = pd.DataFrame(lista_p, columns=['Filo'])
    df_animalia = pd.DataFrame(lista_a, columns=['Filo'])

    fig_fungi = px.pie(df_fungi, names='Filo', title='Fungi - Distribución de Filos', 
                       hover_data={'Filo': True})
    fig_fungi.update_traces(textinfo='label+percent', pull=[0.1, 0.1, 0.1])  # Agregar etiquetas de datos
    fig_plantae = px.pie(df_plantae, names='Filo', title='Plantae - Distribución de Filos', 
                        hover_data={'Filo': True})
    fig_plantae.update_traces(textinfo='label+percent', pull=[0.1, 0.1, 0.1])  # Agregar etiquetas de datos
    fig_animalia = px.pie(df_animalia, names='Filo', title='Animalia - Distribución de Filos', 
                         hover_data={'Filo': True})
    fig_animalia.update_traces(textinfo='label+percent', pull=[0.1, 0.1, 0.1])  # Agregar etiquetas de datos

    app = Dash(__name__)

    app.layout = html.Div([
        html.H1("Distribución de Filos por Reino"),
        html.Div([
            dcc.Graph(figure=fig_fungi),
            dcc.Graph(figure=fig_plantae),
            dcc.Graph(figure=fig_animalia)
        ])
    ])

    if __name__ == '__main__':
        app.run_server(debug=True)
except Exception as ex:
    print("Error durante la conexión o ejecución:", ex)
finally:
    if cursor:
        cursor.close()
    if connection:
        connection.close()
    print("Conexión finalizada")

#Escenario 3

from dash import Dash, html, dcc
import plotly.express as px
import pandas as pd
import psycopg2

try:
    connection = psycopg2.connect(
        host='localhost',
        user='postgres',
        password='123456789',
        database='Proyecto2',
        port="5432"
    )
    print("Conexión exitosa")
    cursor = connection.cursor()
    cursor.execute("select estado_taxonomico, rango_taxonomico from informacion_taxonomica")
    rows = cursor.fetchall()
    
    lista_Aceptado = []
    lista_Dudoso = []
    lista_Sinonimo = []
    lista_Valido = []
    
    for row in rows:
        if row[0] == 'Acepado':
            lista_Aceptado.append(row)
        elif row[0] == 'Dudoso':
            lista_Dudoso.append(row)
        elif row[0] == 'Sinonimo':
            lista_Sinonimo.append(row)
        elif row[0] == 'Valido':
            lista_Valido.append(row)
        else:
            print("No se puede añadir el dato: ", row)

    # Convertir los resultados a DataFrames de Pandas
    df_Aceptado = pd.DataFrame(lista_Aceptado, columns=[ 'id_taxonomia','estado_taxonomico','observacion_taxonomica',' rango_taxonomico','codigo_clasificacion'])
    df_Dudoso = pd.DataFrame(lista_Dudoso, columns=[ 'id_taxonomia','estado_taxonomico','observacion_taxonomica',' rango_taxonomico','codigo_clasificacion'])
    df_Sinonimo = pd.DataFrame(lista_Sinonimo, columns=[ 'id_taxonomia','estado_taxonomico','observacion_taxonomica',' rango_taxonomico','codigo_clasificacion'])
    df_Valido = pd.DataFrame(lista_Valido, columns=[ 'id_taxonomia','estado_taxonomico','observacion_taxonomica',' rango_taxonomico','codigo_clasificacion'])
            
    
    # Contar el número de especies en cada estado de amenaza
    df_Aceptado_count = df_Aceptado['rango_taxonomico'].value_counts().reset_index()
    df_Aceptado_count.columns = ['rango_taxonomico', 'Número de Especies']

    df_Dudoso_count = df_Dudoso['rango_taxonomico'].value_counts().reset_index()
    df_Dudoso_count.columns = ['rango_taxonomico', 'Número de Especies']

    df_Sinonimo_count = df_Sinonimo['rango_taxonomico'].value_counts().reset_index()
    df_Sinonimo_count.columns = ['rango_taxonomico', 'Número de Especies']
     
    df_Valido_count = df_Valido['rango_taxonomico'].value_counts().reset_index()
    df_Valido_count.columns = ['rango_taxonomico', 'Número de Especies']
    app = Dash(_name_)

    # Definir un diccionario de colores específico para cada estado de amenaza
    color_mapping = {
        'EN': '#FF0000',  # Rojo
        'CR': '#FFA500',  # Naranja
        'VU': '#FFFF00',  # Amarillo
    }

    # Obtener el orden de categorías del primer DataFrame
    category_order = df_Aceptado_count['rango_taxonomico'].tolist()

    # Crear las gráficas con colores específicos y el mismo orden de categorías
    fig_Aceptado = px.bar(df_Aceptado_count, 
                     x='rango_taxonomico', 
                     y='Número de Especies', 
                     title='rango_taxonomico - Número de Especies por Estado de Amenaza',
                     color='Estado de Amenaza',
                     color_discrete_map=color_mapping,
                     category_orders={'Estado de Amenaza': category_order})

    fig_Dudoso = px.bar(df_Dudoso_count, 
                      x='rango_taxonomico', 
                      y='Número de Especies', 
                      title='ICZN - Número de Especies por Estado de Amenaza',
                      color='Estado de Amenaza',
                      color_discrete_map=color_mapping,
                      category_orders={'Estado de Amenaza': category_order})

    fig_Sinonimo = px.bar(df_Sinonimo_count, 
                      x='rango_taxonomico', 
                      y='Número de Especies', 
                      title='ICZN - Número de Especies por Estado de Amenaza',
                      color='Estado de Amenaza',
                      color_discrete_map=color_mapping,
                      category_orders={'Estado de Amenaza': category_order})
   
    fig_Valido = px.bar(df_Valido_count, 
                      x='rango_taxonomico', 
                      y='Número de Especies', 
                      title='ICZN - Número de Especies por Estado de Amenaza',
                      color='Estado de Amenaza',
                      color_discrete_map=color_mapping,
                      category_orders={'Estado de Amenaza': category_order})


    # Configurar el fondo transparente para las gráficas
    fig_Aceptado.update_layout({
        'plot_bgcolor': 'rgba(0, 0, 0, 0)',
        'paper_bgcolor': 'rgba(0, 0, 0, 0)',
    })

    fig_Dudoso.update_layout({
        'plot_bgcolor': 'rgba(0, 0, 0, 0)',
        'paper_bgcolor': 'rgba(0, 0, 0, 0)',
    })
    
    fig_Sinonimo.update_layout({
        'plot_bgcolor': 'rgba(0, 0, 0, 0)',
        'paper_bgcolor': 'rgba(0, 0, 0, 0)',
    })
    
    fig_Valido.update_layout({
        'plot_bgcolor': 'rgba(0, 0, 0, 0)',
        'paper_bgcolor': 'rgba(0, 0, 0, 0)',
    })

    app.layout = html.Div([
        html.H1("Análisis de Rango Taxonomico"),
        dcc.Graph(figure=fig_Aceptado),
        dcc.Graph(figure=fig_Dudoso),
        dcc.Graph(figure=fig_Sinonimo),
        dcc.Graph(figure=fig_Valido),
        html.P("Con esto concluiríamos el análisis del proyecto esperando que sea de su agrado.")
    ], style={'backgroundColor': '#FFFFFF'})  # Color de fondo de la página

    if _name_ == '_main_':
        app.run_server(debug=True)
        
        
except Exception as ex:
    print("Error durante la conexión o ejecución:", ex)
finally:
    if cursor:
        cursor.close()
    if connection:
        connection.close()
        

    print("Conexión finalizada")
